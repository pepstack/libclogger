/*******************************************************************************
* Copyright © 2024-2025 Light Zhang <mapaware@hotmail.com>, MapAware, Inc.     *
* ALL RIGHTS RESERVED.                                                         *
*                                                                              *
* PERMISSION IS HEREBY GRANTED, FREE OF CHARGE, TO ANY PERSON OR ORGANIZATION  *
* OBTAINING A COPY OF THE SOFTWARE COVERED BY THIS LICENSE TO USE, REPRODUCE,  *
* DISPLAY, DISTRIBUTE, EXECUTE, AND TRANSMIT THE SOFTWARE, AND TO PREPARE      *
* DERIVATIVE WORKS OF THE SOFTWARE, AND TO PERMIT THIRD - PARTIES TO WHOM THE  *
* SOFTWARE IS FURNISHED TO DO SO, ALL SUBJECT TO THE FOLLOWING :               *
*                                                                              *
* THE COPYRIGHT NOTICES IN THE SOFTWARE AND THIS ENTIRE STATEMENT, INCLUDING   *
* THE ABOVE LICENSE GRANT, THIS RESTRICTION AND THE FOLLOWING DISCLAIMER, MUST *
* BE INCLUDED IN ALL COPIES OF THE SOFTWARE, IN WHOLE OR IN PART, AND ALL      *
* DERIVATIVE WORKS OF THE SOFTWARE, UNLESS SUCH COPIES OR DERIVATIVE WORKS ARE *
* SOLELY IN THE FORM OF MACHINE - EXECUTABLE OBJECT CODE GENERATED BY A SOURCE *
* LANGUAGE PROCESSOR.                                                          *
*                                                                              *
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR   *
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,     *
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON - INFRINGEMENT.IN NO EVENT   *
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE    *
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,  *
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER  *
* DEALINGS IN THE SOFTWARE.                                                    *
*******************************************************************************/
/*
** @file      timeut.h
**    date time utility api.
**
** @author mapaware@hotmail.com
** @version 0.0.2
** @since 2017-08-28 11:12:10
** @date 2025-03-17 00:36:13
*/
#ifndef _TIMEUT_H__
#define _TIMEUT_H__


#if defined(__cplusplus)
extern "C"
{
#endif

#include "mscrtdbg.h"
#include "basetype.h"

#include <immintrin.h>

#if defined(__x86_64__) || defined(__i386__) || defined(_M_X64) || defined(_M_IX86)
#include <immintrin.h>
#define CPU_PAUSE() _mm_pause()
#elif defined(__aarch64__) || defined(__arm__)
#define CPU_PAUSE() __asm__ __volatile__("yield" ::: "memory")
#else
#define CPU_PAUSE() // 无操作或其他架构实现
#endif


#if defined(__WINDOWS__)

    static void sleep_msec(int milliseconds)
    {
        Sleep(milliseconds);
    }


    static void sleep_usec(int microseconds)
    {
        int ms = microseconds / 1000;
        int us = microseconds % 1000;

        if (ms > 0) {
            Sleep(ms);
        }

        if (us > 0) {
            LARGE_INTEGER lval = { 0 };
            LONGLONG startTime;
            double cpuFreq, delayTimeUs = 0;

            // get cpuFreq
            if (!QueryPerformanceFrequency(&lval)) {
                return;
            }
            cpuFreq = (double)lval.QuadPart;
            if (cpuFreq < 1000) {
                return;
            }

            // get startTime
            if (!QueryPerformanceCounter(&lval)) {
                return;
            }
            startTime = lval.QuadPart;

            do {
                CPU_PAUSE();
                if (!QueryPerformanceCounter(&lval)) {
                    return;
                }
                delayTimeUs = (((double)(lval.QuadPart - startTime)) / cpuFreq) * 1000000;
            } while (delayTimeUs < us);
        }
    }

#else /* non-windows: Linux or Cygwin */

#ifndef _TIMESPEC_DEFINED
# define _TIMESPEC_DEFINED
#endif

    /* sleep in milliseconds */
    NOWARNING_UNUSED(static) void sleep_msec(int milliseconds)
    {
        if (milliseconds > 0) {
            struct timespec ts;
            ts.tv_sec = milliseconds / 1000;
            ts.tv_nsec = (milliseconds % 1000) * 1000000;
            nanosleep(&ts, 0);
        }
    }

    /* sleep in micro seconds, do not use usleep */
    NOWARNING_UNUSED(static) void sleep_usec(int us)
    {
        if (us > 0) {
            /**
            * 1 sec = 1000 ms (millisec)
            * 1 ms = 1000 us (microsec)
            * 1 us = 1000 ns (nanosec)
            * 1 sec = 1000 000 000 ns (nanosec)
            */
            struct timespec ts;

            ts.tv_sec = us / 1000000;
            ts.tv_nsec = (us % 1000000) * 1000;

            nanosleep(&ts, 0);
        }
    }

#endif


NOWARNING_UNUSED(static)
const char *timezone_format(long tz, char *tzfmt)
{
    if (tz < 0) {
        snprintf_chkd_V1(tzfmt, 5 + 1, "+%02d%02d", -(int)(tz / 3600), -(int)((tz % 3600) / 60));
    } else if (tz > 0) {
        snprintf_chkd_V1(tzfmt, 5 + 1, "-%02d%02d", (int)(tz / 3600), (int)((tz % 3600) / 60));
    } else {
        /* UTC */
        memcpy(tzfmt, "+0000", 5);
    }
    tzfmt[5] = 0;
    return tzfmt;
}


NOWARNING_UNUSED(static)
long timezone_compute(time_t ts, char *tzfmt)
{
    long tz;
    time_t ut;
    struct tm t;

#if defined(__WINDOWS__)
    if (gmtime_s(&t, &ts) != (errno_t)0) {
        /* error */
        perror("gmtime_s\n");
        return (-1);
    }
    ut = mktime(&t);
#else
    if (!gmtime_r(&ts, &t)) {
        /* error */
        perror("gmtime\n");
        return (-1);
    }
    ut = mktime(&t);
#endif

    tz = (long)difftime(ut, ts);
    if (tzfmt) {
        timezone_format(tz, tzfmt);
    }

    return tz;
}


NOWARNING_UNUSED(static)
int daylight_compute(time_t ts)
{
    struct tm tm;
    tm.tm_isdst = 0;

#if defined(__WINDOWS__)
    localtime_s(&tm, &ts);
#else
    localtime_r(&ts, &tm);
#endif

    return tm.tm_isdst;
}


NOWARNING_UNUSED(static)
void getnowtimeofday(struct timespec *now)
{
#if defined(_WIN32)
    FILETIME tmfile;
    ULARGE_INTEGER _100nanos;

    GetSystemTimeAsFileTime(&tmfile);

    _100nanos.LowPart   = tmfile.dwLowDateTime;
    _100nanos.HighPart  = tmfile.dwHighDateTime;
    _100nanos.QuadPart -= 0x19DB1DED53E8000;

    /* Convert 100ns units to seconds */
    now->tv_sec = (time_t)(_100nanos.QuadPart / (10000 * 1000));

    /* Convert remainder to nanoseconds */
    now->tv_nsec = (long) ((_100nanos.QuadPart % (10000 * 1000)) * 100);
#else
    if (clock_gettime(CLOCK_REALTIME, now) == -1) {
        /* must be successful */
        perror("clock_gettime");
        exit(EXIT_FAILURE);
    }
#endif
}


/**
 * taken from: redis/src/localtime.c
 *   although localtime_s on windows is a bit faster than getlocaltime_safe,
 *   here we use getlocaltime_safe due to it cross-platforms.
 */
NOWARNING_UNUSED(static)
void getlocaltime_safe(struct tm *loc, int64_t t, int tz, int dst)
{
/**
 * A year not divisible by 4 is not leap.
 * If div by 4 and not 100 is surely leap.
 * If div by 100 *and* 400 is not leap.
 * If div by 100 and not by 400 is leap.
 */
#define YEAR_IS_LEAPYEAR(year) ((year) % 4 ? 0 : ((year) % 100 ? 1 : ((year) % 400 ? 0 : 1)))
#define SECONDS_PER_MINUTE ((time_t)60)
#define SECONDS_PER_HOUR ((time_t)3600)
#define SECONDS_PER_DAY ((time_t)86400)

    /* We need to calculate in which month and day of the month we are. To do
     * so we need to skip days according to how many days there are in each
     * month, and adjust for the leap year that has one more day in February.
     */
    static const int mean_mdays[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    static const int leap_mdays[12] = {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

    /* Adjust for timezone. 0 for UTC */
    t -= tz;

    /* Adjust for daylight time. 0 default */
    t += 3600 * dst;

    /* Days passed since epoch. */
    int64_t days = t / SECONDS_PER_DAY;

    /* Remaining seconds. */
    int64_t seconds = t % SECONDS_PER_DAY;

    loc->tm_isdst = dst;
    loc->tm_hour = (int)(seconds / SECONDS_PER_HOUR);
    loc->tm_min = (int)((seconds % SECONDS_PER_HOUR) / SECONDS_PER_MINUTE);
    loc->tm_sec = (int)((seconds % SECONDS_PER_HOUR) % SECONDS_PER_MINUTE);

    /* 1/1/1970 was a Thursday, that is, day 4 from the POV of the tm structure
     * where sunday = 0, so to calculate the day of the week we have to add 4
     * and take the modulo by 7. */
    loc->tm_wday = (int)((days + 4) % 7);

    /* Calculate the current year. */
    loc->tm_year = 1970;

    while (1) {
        /* Leap years have one day more. */
        int64_t days_this_year = 365 + YEAR_IS_LEAPYEAR(loc->tm_year);
        if (days_this_year > days)
            break;
        days -= days_this_year;
        loc->tm_year++;
    }

    /* Number of day of the current year. */
    loc->tm_yday = (int)days;
    loc->tm_mon = 0;

    if (YEAR_IS_LEAPYEAR(loc->tm_year)) {
        while (days >= leap_mdays[loc->tm_mon]) {
            days -= leap_mdays[loc->tm_mon];
            loc->tm_mon++;
        }
    } else {
        while (days >= mean_mdays[loc->tm_mon]) {
            days -= mean_mdays[loc->tm_mon];
            loc->tm_mon++;
        }
    }

    /* Add 1 since our 'days' is zero-based. */
    loc->tm_mday = (int)(days + 1);

    /* Surprisingly tm_year is year-1900. */
    loc->tm_year -= 1900;

#undef SECONDS_PER_MINUTE
#undef SECONDS_PER_HOUR
#undef SECONDS_PER_DAY
#undef YEAR_IS_LEAPYEAR
}

/**
 * 计算两个timespec结构体之间的时间差（毫秒），或单个时间/当前时间的毫秒表示。
 * 参数：
 *   oldtms - 旧时间点。若与newtms同时提供，则计算两者差值；若单独提供，则返回其时间值的毫秒数。
 *   newtms - 新时间点。若与oldtms同时提供，则计算两者差值；若单独提供，则返回其时间值的毫秒数。
 *           若两者均为NULL，则返回当前时间的毫秒数。
 * 返回值：
 *   时间差或时间值的毫秒数，以sb8类型（有符号64位整数）返回，可能为负数。
 */
NOWARNING_UNUSED(static)
sb8 difftime_msec(const struct timespec *oldtms, const struct timespec *newtms)
{
    sb8 sec = 0;   // 存储秒数部分
    sb8 nsec = 0;  // 存储纳秒部分

    // 根据参数情况计算sec和nsec的值
    if (!oldtms && !newtms) {
        /* get current timestamp in ms */
        struct timespec now;
        getnowtimeofday(&now);
        sec = now.tv_sec;
        nsec = now.tv_nsec;
    } else if (oldtms && newtms) {
        sec = (sb8)(newtms->tv_sec - oldtms->tv_sec);
        nsec = (sb8)(newtms->tv_nsec - oldtms->tv_nsec);
    } else if (newtms) {
        sec = (sb8)(newtms->tv_sec);
        nsec = (sb8)(newtms->tv_nsec);
    } else if (oldtms) {
        sec = (sb8)(oldtms->tv_sec);
        nsec = (sb8)(oldtms->tv_nsec);
    }

    if (sec > 0) {
        if (nsec >= 0) {
            return ((sec * 1000UL) + nsec / 1000000UL);
        } else { /* nsec < 0 */
            return (sec - 1) * 1000UL + (nsec + 1000000000UL) / 1000000UL;
        }
    } else if (sec < 0) {
        if (nsec <= 0) {
            return ((sec * 1000UL) + nsec / 1000000UL);
        } else{ /* nsec > 0 */
            return (sec + 1) * 1000UL + (nsec - 1000000000UL) / 1000000UL;
        }
    } else { /* sec = 0 */
        return nsec / 1000000UL;
    }
}


NOWARNING_UNUSED(static)
const char * format_nowtimeofday (char *datefmt)
{
    struct timespec now;
    struct tm loc;

    getnowtimeofday(&now);
    getlocaltime_safe(&loc, now.tv_sec, 0, 0);

    snprintf_chkd_V1(datefmt, 24, "%04d-%02d-%02d %02d:%02d:%02d UTC", loc.tm_year + 1900, loc.tm_mon + 1, loc.tm_mday, loc.tm_hour, loc.tm_min, loc.tm_sec);

    datefmt[23] = 0;
    return datefmt;
}

#ifdef __cplusplus
}
#endif

#endif /* _TIMEUT_H__ */
