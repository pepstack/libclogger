/*******************************************************************************
* Copyright © 2024-2025 Light Zhang <mapaware@hotmail.com>, MapAware, Inc.     *
* ALL RIGHTS RESERVED.                                                         *
*                                                                              *
* PERMISSION IS HEREBY GRANTED, FREE OF CHARGE, TO ANY PERSON OR ORGANIZATION  *
* OBTAINING A COPY OF THE SOFTWARE COVERED BY THIS LICENSE TO USE, REPRODUCE,  *
* DISPLAY, DISTRIBUTE, EXECUTE, AND TRANSMIT THE SOFTWARE, AND TO PREPARE      *
* DERIVATIVE WORKS OF THE SOFTWARE, AND TO PERMIT THIRD - PARTIES TO WHOM THE  *
* SOFTWARE IS FURNISHED TO DO SO, ALL SUBJECT TO THE FOLLOWING :               *
*                                                                              *
* THE COPYRIGHT NOTICES IN THE SOFTWARE AND THIS ENTIRE STATEMENT, INCLUDING   *
* THE ABOVE LICENSE GRANT, THIS RESTRICTION AND THE FOLLOWING DISCLAIMER, MUST *
* BE INCLUDED IN ALL COPIES OF THE SOFTWARE, IN WHOLE OR IN PART, AND ALL      *
* DERIVATIVE WORKS OF THE SOFTWARE, UNLESS SUCH COPIES OR DERIVATIVE WORKS ARE *
* SOLELY IN THE FORM OF MACHINE - EXECUTABLE OBJECT CODE GENERATED BY A SOURCE *
* LANGUAGE PROCESSOR.                                                          *
*                                                                              *
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR   *
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,     *
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON - INFRINGEMENT.IN NO EVENT   *
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE    *
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,  *
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER  *
* DEALINGS IN THE SOFTWARE.                                                    *
*******************************************************************************/
/*
** @file cgtypes.h
** @brief C Gemoetry Types Definitions
**
** @author mapaware@hotmail.com
** @copyright © 2024-2030 mapaware.top All Rights Reserved.
** @version 0.1.3
**
** @since 2024-10-16 12:45:30
** @date 2024-12-06 00:59:07
**
** @note
*/
#ifndef CG_TYPES_H__
#define CG_TYPES_H__


#if defined(__cplusplus)
extern "C"
{
#endif

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#include <string.h>
#include <float.h>
#include <math.h>
#include <memory.h>
#include <assert.h>


/**
 * TODO:
 * SSE2
 *   https://zhuanlan.zhihu.com/p/591900754
 */
#if defined _MSC_VER && defined _M_X64 || (defined __GNUC__ && defined __SSE2__&& !defined __APPLE__)
# include <emmintrin.h>
#endif


#ifdef _DEBUG
# define _Assert(x)  assert(x)
#else
# define _Assert(x)
#endif


#ifndef M_PI
# define MATH_PI     3.14159265358979323846
# define MATH_2PI    6.28318530717958647692
# define MATH_SQRT2  1.41421356237309504880
#else
# define MATH_PI     M_PI
# define MATH_2PI    (2 * M_PI)
# define MATH_SQRT2  M_SQRT2
#endif

     // <float.h>
#define CG_FLT_EPSILON  FLT_EPSILON
#define CG_DBL_EPSILON  DBL_EPSILON

// <stdint.h>
#define UINT64_LODWORD(x)  ((uint64_t)((x) & 0xFFFFFFFF))
#define UINT64_HIDWORD(x)  ((uint64_t)((x) >> 32))


typedef struct CG_point2f_t
{
    float X;
    float Y;
} CG_point2f;

typedef struct CG_point2d_t
{
    double X;
    double Y;
} CG_point2d;

typedef struct CG_point2_t
{
    int64_t X;
    int64_t Y;
} CG_point2;

typedef struct CG_segment2_t
{
    CG_point2 Va;   // start vert of edge: a
    CG_point2 Vb;   // end vert of edge: b
} CG_seg2;

typedef struct CG_box2f_t
{
    float Xmin;
    float Ymin;
    float Xmax;
    float Ymax;
} CG_box2f;

typedef struct CG_box2d_t
{
    double Xmin;
    double Ymin;
    double Xmax;
    double Ymax;
} CG_box2d;

typedef struct CG_box2_t
{
    int64_t Xmin;
    int64_t Ymin;
    int64_t Xmax;
    int64_t Ymax;
} CG_box2;

typedef struct CG_uint128_t
{
    uint64_t result;
    uint64_t carry;
} CG_dbuint64;


static const CG_box2    CG_box2_empty_static = { 0L, 0L, 0L, 0L };

static const CG_box2d   CG_box2d_empty_static = { 0.0, 0.0, 0.0, 0.0 };

static const CG_box2f   CG_box2f_empty_static = { 0.0f, 0.0f, 0.0f, 0.0f };

static const CG_point2  CG_point2_zero_static = { 0, 0 };

static const CG_point2f CG_point2f_zero_static = { 0.0f, 0.0f };

static const CG_point2d CG_point2d_zero_static = { 0.0, 0.0 };


#define CG_ABS(v)         ((v) < 0? -(v):(v))
#define CG_TriSign(x)     (((x) > 0) - ((x) < 0))

#define CG_Min2V(a, b)    ((a) < (b) ? (a) : (b))
#define CG_Max2V(a, b)    ((a) > (b) ? (a) : (b))

#define CG_Clamp2V(v, minV, maxV)  ((v)<(minV)? (minV):((v)>(maxV)? (maxV):(v)))

#define CG_Round2Int64(d)  ((int64_t)((d) > 0 ? (d) + 0.5f : ((d) < 0? (d) - 0.5f : (d))))

static int64_t CG_RoundToInt64(double d)
{
    return CG_Round2Int64(d);
}

#define CG_RectWidth(box)   (box.Xmax - box.Xmin)
#define CG_RectHeight(box)   (box.Ymax - box.Ymin)

#define CG_RectIsOverlap(a, b)   ((a).Xmin<(b).Xmax && (a).Ymin<(b).Ymax && (b).Xmin<(a).Xmax && (b).Ymin<(a).Ymax)

#define CG_RectContains(outrc, inrc)   ((outrc).Xmin <= (inrc).Xmin && (outrc).Ymin <= (inrc).Ymin && (outrc).Xmax >= (inrc).Xmax && (outrc).Ymax >= (inrc).Ymax)

#define CG_RectInflate(box, d)   do { box.Xmin -= d; box.Ymin -= d; box.Xmax += d; box.Ymax += d; } while(0)

#define CG_RectOffset(rc, DX, DY)   (rc).Xmin += (DX); (rc).Xmax += (DX); (rc).Ymin += (DY); (rc).Ymax += (DY)

#define CG_TranslatePoint2(pt, dX, dY)  (pt).X += (dX); (pt).Y += (dY)

#define CG_ReflectPoint2(pt, pivotX, pivotY)  pt.X = (pivotX - pt.X + pivotX); pt.Y = (pivotY - pt.Y + pivotY)

#define CG_PointToRect(pt, DX, DY, rc)  \
(rc).Xmin=(pt).X-(DX); (rc).Xmax=(pt).X+(DX); (rc).Ymin=(pt).Y-(DY); (rc).Ymax=(pt).Y+(DY)

#define CG_Point2IsEqual(a, b)  ((a).X == (b).X && (a).Y == (b).Y)

#define CG_Point2Set(p, valX, valY)  (p).X = (valX); (p).Y = (valY)

#define CG_Point2Dup(dst, src)  (dst).X = (src).X; (dst).Y = (src).Y

#define CG_RectMakeEmty(rc)   memset(&(rc), 0, sizeof(rc))

#define CG_RectIsEmpty(rc)     ((rc).Xmax <= (rc).Xmin || (rc).Ymax <= (rc).Ymin)

#define CG_PtInsideRect(rc, X, Y)   ((X) > (rc).Xmin && (X) < (rc).Xmax && (Y) > (rc).Ymin && (Y) < (rc).Ymax)

#define CG_PtOutsideRect(rc, X, Y)  ((X) < (rc).Xmin || (X) > (rc).Xmax || (Y) < (rc).Ymin || (Y) > (rc).Ymax)


#define CG_CrossProduct3(v1, v2, v3)  (((v2).X - (v1).X) * ((v3).Y - (v2).Y) - ((v2).Y - (v1).Y) * ((v3).X - (v2).X))

#define CG_CrossProduct2(va, vb)      (((va).Y * (vb).X) - ((vb).Y * (va).X))

#define CG_DotProduct3(v1, v2, v3)    (((v2).X - (v1).X) * ((v3).X - (v2).X) + ((v2).Y - (v1).Y) * ((v3).Y - (v2).Y))

#define CG_DotProduct2(v1, v2)        (((v1).X * (v2).X) + ((v1).Y * (v2).Y))


#define CG_RectConcatPoint(dst, pv) do { \
    if ((pv).X < (dst).Xmin) { \
        (dst).Xmin = (pv).X; \
    } \
    else if ((pv).X > (dst).Xmax) { \
        (dst).Xmax = (pv).X; \
    } \
    if ((pv).Y < (dst).Ymin) { \
        (dst).Ymin = (pv).Y; \
    } \
    else if ((pv).Y > (dst).Ymax) { \
        (dst).Ymax = (pv).Y; \
    } \
    } while(0)


#define CG_RectConcatRect(dst, src) do { \
    if ((src).Xmin < (dst).Xmin) { \
        (dst).Xmin = (src).Xmin; \
    } \
    else if ((src).Xmax > (dst).Xmax) { \
        (dst).Xmax = (src).Xmax; \
    } \
    if ((src).Ymin < (dst).Ymin) { \
        (dst).Ymin = (src).Ymin; \
    } \
    else if ((src).Ymax > (dst).Ymax) { \
        (dst).Ymax = (src).Ymax; \
    } \
    } while(0)


#define CG_TrigonArea2(pt1, pt2, pt3)  (((pt2).X - (pt1).X) * ((pt3).Y - (pt1).Y) - ((pt2).Y - (pt1).Y) * ((pt3).X - (pt1).X))


// given that this is an internal function, and given the x and y parameters
// will always be coordinate values (or the difference between coordinate values),
// x and y should always be within INT64_MIN to INT64_MAX. Consequently,
// there should be no risk that the following computation will overflow
// see https://stackoverflow.com/a/32436148/359538

#ifdef MATH_HYPOT_FLOAT
# define CG_HypotFloat(X, Y)  hypotf((float)(X), (float)(Y))
#else
static float CG_HypotFloat(float x, float y)
{
    float abs_x = CG_ABS(x);
    float abs_y = CG_ABS(y);
    if (abs_x > abs_y) {
        float tmp_v = abs_y / abs_x;
        return abs_x * sqrtf(1.0f + tmp_v * tmp_v);
    }
    else if (abs_y > abs_x) {
        float tmp_v = abs_x / abs_y;
        return abs_y * sqrtf(1.0f + tmp_v * tmp_v);
    }
    else {
        return abs_x * (float)MATH_SQRT2;
    }
}
#endif

#ifdef MATH_HYPOT_DOUBLE
# define CG_HypotDouble(X, Y)  hypot((double)(X), (double)(Y))
#else
static double CG_HypotDouble(double x, double y)
{
    double abs_x = CG_ABS(x);
    double abs_y = CG_ABS(y);
    if (abs_x > abs_y) {
        double tmp_v = abs_y / abs_x;
        return abs_x * sqrt(1.0 + tmp_v * tmp_v);
    }
    else if (abs_y > abs_x) {
        double tmp_v = abs_x / abs_y;
        return abs_y * sqrt(1.0 + tmp_v * tmp_v);
    }
    else {
        return abs_x * MATH_SQRT2;
    }
}
#endif

static void CG_UnitNormPt2f(const CG_point2* pt1, const CG_point2* pt2, CG_point2f* normV)
{
    if (CG_Point2IsEqual(*pt1, *pt2)) {
        *normV = CG_point2f_zero_static;
    }
    else {
        float dX = (float)(pt2->X - pt1->X);
        float dY = (float)(pt2->Y - pt1->Y);

        float invHypot = 1.0f / CG_HypotFloat(dX, dY);

        dX *= invHypot;
        dY *= invHypot;

        normV->X = CG_Clamp2V(dY, -1.0f, 1.0f);
        normV->Y = -CG_Clamp2V(dX, -1.0f, 1.0f);
    }
}

static void CG_UnitNormPt2d(const CG_point2* pt1, const CG_point2* pt2, CG_point2d* normV)
{
    if (CG_Point2IsEqual(*pt1, *pt2)) {
        *normV = CG_point2d_zero_static;
    }
    else {
        double dX = (double)(pt2->X - pt1->X);
        double dY = (double)(pt2->Y - pt1->Y);
        double invHypot = 1.0 / CG_HypotDouble(dX, dY);
        dX *= invHypot;
        dY *= invHypot;
        normV->X = CG_Clamp2V(dY, -1.0, 1.0);
        normV->Y = -CG_Clamp2V(dX, -1.0, 1.0);
    }
}


static void CG_UnitNormV2f(float X, float Y, CG_point2f* normV)
{
    float hf = CG_HypotFloat(X, Y);
    if (hf < CG_FLT_EPSILON) {
        normV->X = 0.0f;
        normV->Y = 0.0f;
    }
    else {
        float invHypot = 1.0f / hf;
        X *= invHypot;
        Y *= invHypot;
        normV->X = CG_Clamp2V(X, -1.0f, 1.0f);
        normV->Y = CG_Clamp2V(Y, -1.0f, 1.0f);
    }
}


// #834, #835
static void CG_Uint64Multiply(uint64_t a, uint64_t b, struct CG_uint128_t* product)
{
    uint64_t loa = UINT64_LODWORD(a);
    uint64_t lob = UINT64_LODWORD(b);
    uint64_t hia = UINT64_HIDWORD(a);
    uint64_t hib = UINT64_HIDWORD(b);

    uint64_t x1 = loa * lob;
    uint64_t x2 = hia * lob + UINT64_HIDWORD(x1);
    uint64_t x3 = loa * hib + UINT64_LODWORD(x2);

    product->result = UINT64_LODWORD(x3) << 32 | UINT64_LODWORD(x1);
    product->carry = hia * hib + UINT64_HIDWORD(x2) + UINT64_HIDWORD(x3);
}


// returns true if (and only if) a * b == c * d
static bool CG_Int64ProductEqual(int64_t a, int64_t b, int64_t c, int64_t d)
{
#if (defined(__clang__) || defined(__GNUC__)) && UINTPTR_MAX >= UINT64_MAX
    __int128_t la = (__int128_t)a;
    __int128_t lb = (__int128_t)b;
    __int128_t lc = (__int128_t)c;
    __int128_t ld = (__int128_t)d;
    return la * lb == lc * ld;
#else
    // nb: unsigned values needed for calculating overflow carry
    uint64_t ua = CG_TriSign(a) * a;
    uint64_t ub = CG_TriSign(b) * b;
    uint64_t uc = CG_TriSign(c) * c;
    uint64_t ud = CG_TriSign(d) * d;

    struct CG_uint128_t Uab, Ucd;

    CG_Uint64Multiply(ua, ub, &Uab);
    CG_Uint64Multiply(uc, ud, &Ucd);

    // nb: it's important to differentiate 0 values here from other values
    if (CG_TriSign(a) * CG_TriSign(b) == CG_TriSign(c) * CG_TriSign(d)) {
        return (Uab.result == Ucd.result && Uab.carry == Ucd.carry);
    }
    else {
        return false;
    }
#endif
}


// 3 点是否共线
// #777
static bool CG_Point2IsCollinear(const CG_point2* pt1, const CG_point2* share, const CG_point2* pt2)
{
    int64_t a = share->X - pt1->X;
    int64_t b = pt2->Y - share->Y;
    int64_t c = share->Y - pt1->Y;
    int64_t d = pt2->X - share->X;

    // When checking for collinearity with very large coordinate values
    // then ProductsAreEqual is more accurate than using CG_CrossProduct3
    return CG_Int64ProductEqual(a, b, c, d);
}


// pt(X, Y) perpendic dist to line[start, end]
static double CG_PointToLineDist(int64_t X, int64_t Y, CG_point2 start, CG_point2 end)
{
    // perpendicular distance of point (x³,y³) = (Ax³ + By³ + C)/Sqrt(A² + B²)
    //  see http://en.wikipedia.org/wiki/Perpendicular_distance
    int64_t C = end.X - start.X;
    int64_t D = end.Y - start.Y;

    int64_t A = X - start.X;
    int64_t B = Y - start.Y;

    if (C == 0 && D == 0) {
        // 当直线为一个点, 返回点到点的距离
        return CG_HypotDouble((double) A, (double) B);
    }
    return (double) (A * D - C * B) * CG_HypotDouble((double) C, (double) D);
}


// pt(X, Y) perpendic dist to line[start, end]
static double CG_PointToLineDistSq(int64_t X, int64_t Y, CG_point2 start, CG_point2 end)
{
    // perpendicular distance of point (x³,y³) = (Ax³ + By³ + C)/Sqrt(A² + B²)
    //  see http://en.wikipedia.org/wiki/Perpendicular_distance
    int64_t C = end.X - start.X;
    int64_t D = end.Y - start.Y;

    int64_t A = X - start.X;
    int64_t B = Y - start.Y;

    if (C == 0 && D == 0) {
        // 当直线为一个点, 返回点到点的距离平方
        return ((double) A * (double) A + (double) B * (double) B);
    }

    double V = (double) (A * D - C * B);
    return (V / (C * C + D * D)) * V;
}

// pt(X, Y) perpendic dist to line[start, end]
static double CG_Point2dToLineDistSq(const CG_point2d *pt, const CG_point2d *start, const CG_point2d *end, double epsilon)
{
    // perpendicular distance of point (x³,y³) = (Ax³ + By³ + C)/Sqrt(A² + B²)
    //  see http://en.wikipedia.org/wiki/Perpendicular_distance
    double C = end->X - start->X;
    double D = end->Y - start->Y;

    if (CG_ABS(C) < epsilon && CG_ABS(D) < epsilon) {
        double dX = (start->X + end->X) / 2 - pt->X;
        double dY = (start->Y + end->Y) / 2 - pt->Y;

        // 当直线为一个点, 返回点到点的距离平方
        return (dX * dX + dY * dY);
    }

    double A = pt->X - (double)start->X;
    double B = pt->Y - (double)start->Y;
    double V = (double)(A * D - C * B);
    return (V / (C * C + D * D)) * V;
}


// 返回 path 的点到直线 [start,end] 的最大距离点的索引 imax 和最大距离的平方 maxDistSq
static int CG_PointToPathDistSq(CG_point2 start, CG_point2 end, const CG_point2* path, int np, double* distSq)
{
    int maxAt = 0;
    double distSqMax = 0;
    double dist2;

    // 计算全部点到直线的距离, 找出最大的点
    const CG_point2* p = path;
    for (int i = 0; i < np; i++) {
        dist2 = CG_PointToLineDistSq(p->X, p->Y, start, end);
        if (dist2 > distSqMax) {
            distSqMax = dist2;
            maxAt = i;
        }
        ++p;
    }
    *distSq = distSqMax;
    return maxAt;
}


//
// CG_SimplifyPathRecursive
//
//  曲线重采样拟合, 返回拟合之后的pout数组的点数
//
static void CG_SimplifyPathRecursive(CG_point2 start, CG_point2 end, const CG_point2* path, int np, CG_point2* outpath, int* outnp, double epsilonSq)
{
    if (np > 0) {
        double distSqMax;
        int maxAt = CG_PointToPathDistSq(start, end, path, np, &distSqMax);
        if (distSqMax < epsilonSq) {
            return;
        }
        CG_SimplifyPathRecursive(start, path[maxAt], path, maxAt, outpath, outnp, epsilonSq);
        outpath[(*outnp)++] = path[maxAt];
        CG_SimplifyPathRecursive(path[maxAt], end, &path[maxAt + 1], np - maxAt - 1, outpath, outnp, epsilonSq);
    }
}


/**
 * CG_CubicBezToPt
 *   Cubic Bezier 曲线插值拟合点坐标
 *
 * Cubic Bezier 三次 Bezier 曲线由 4 个点定义
 * P 包含 4 个点:
 *   ‌P[0‌] 起点，坐标为(0, 0)
‌ *   P[1] 第一个控制点，坐标为(x1, y1)
‌ *   P[2‌] 第二个控制点，坐标为(x2, y2)
‌ *   P[3‌] 终点，坐标为(1, 1)
 *
 * vertsList: 至少有4个点, 每次增加3个点的倍数
 * numVerts: 4, 7, 10, 13, 16, ...
 * arcBias:  曲线弧拟合偏差
 *
 * CubicBez=(P[0]~P[3]) 曲线上任意一点P(t)的位置可以通过以下公式计算：
 *
 * [ P(t) = (1-t)^3P_0 + 3(1-t)^2tP_1 + 3(1-t)t^2P_2 + t^3P_3 ]
 *
 *  其中，t=(0, 1) 是一个在0到1之间变化的参数，表示曲线上的位置‌。
 */
static void CG_CubicBezToPt(const CG_point2* P, double t, double *Xt, double *Yt)
{
    double A = (1 - t) * (1 - t) * (1 - t);
    double B = 3 * (1 - t) * (1 - t) * t;
    double C = 3 * (1 - t) * t * t;
    double D = t * t * t;

    *Xt = A * P[0].X + B * P[1].X + C * P[2].X + D * P[3].X;
    *Yt = A * P[0].Y + B * P[1].Y + C * P[2].Y + D * P[3].Y;
}


// 计算2条直线 a, b 的交点
static bool CG_Line2Intersect(CG_point2 a1, CG_point2 a2, CG_point2 b1, CG_point2 b2, CG_point2d *pt)
{
    int64_t dx1 = (a2.X - a1.X);
    int64_t dy1 = (a2.Y - a1.Y);
    int64_t dx2 = (b2.X - b1.X);
    int64_t dy2 = (b2.Y - b1.Y);

    int64_t det = dy1 * dx2 - dy2 * dx1;
    if (det == 0) {
        return false;
    }

    int64_t val = (a1.X - b1.X) * dy2 - (a1.Y - b1.Y) * dx2;

    int d = CG_TriSign(det);
    int v = CG_TriSign(val);

    // t = val / det;
    if (d * v <= 0) {
        // t <= 0.0
        pt->X = (double) a1.X;
        pt->Y = (double) a1.Y;
    }
    else if ((val * v) >= (det * d)) {
        // t >= 1.0
        pt->X = (double) a2.X;
        pt->Y = (double) a2.Y;
    }
    else {
        double t = ((double)val) / ((double)det);
        pt->X = (double)(a1.X + t * dx1);
        pt->Y = (double)(a1.Y + t * dy1);
    }

    return true;
}


/**
 *
 * relation between 2 edges: [a1, a2], [b1, b2]
 * returns:
 *   2 - line a is parallel to line b
 *   1 - edge a has no joint with line b: both start and end points of edge a are on the same side of line b
 *   0 - edge a's start or end point is on the line b
 *  -1 - edge a has an inner joint with line b: the joint point is on the edge a except for start and end vertices.
 *       to justify if edge a and edge b is joint, must call this function twice as below:
 *
 *     if (CG_Edge2Relation(a1, a2, b1, b2) == EDGE2_INNERJOIN && CG_Edge2Relation(b1, b2, a1, a2) == EDGE2_INNERJOIN) {
 *         printf("edge a and edge b has a inner joint point!/n");
 *     }
 */
#define EDGE2_PARALLEL		 2
#define EDGE2_NOTJOIN		 1
#define EDGE2_ENDJOIN	     0
#define EDGE2_INNERJOIN     -1

static int CG_Edge2Relation(CG_point2 a1, CG_point2 a2, CG_point2 b1, CG_point2 b2)
{
    int64_t	Xb = b2.X - b1.X;
    int64_t	Yb = b2.Y - b1.Y;
    int64_t	Xa = a2.X - a1.X;
    int64_t	Ya = a2.Y - a1.Y;

    int64_t	X1 = a1.X - b1.X;
    int64_t	Y1 = a1.Y - b1.Y;
    int64_t	X2 = a2.X - b2.X;
    int64_t	Y2 = a2.Y - b2.Y;

    if (Yb * Xa == Xb * Ya) {
        return  EDGE2_PARALLEL;
    }

    Xa = Xb * Y1 - Yb * X1;
    Ya = Xb * Y2 - Yb * X2;

    return CG_TriSign(Xa) * CG_TriSign(Ya);
}


// Get intersect point of edge a with edge b
static bool CG_Edge2Intersect(CG_point2 a1, CG_point2 a2, CG_point2 b1, CG_point2 b2, CG_point2d *pt)
{
    int A = CG_Edge2Relation(a1, a2, b1, b2);
    if (A == EDGE2_NOTJOIN) {
        return false;
    }

    if (A == EDGE2_PARALLEL) {
        if (CG_Point2IsEqual(a1, b1) || CG_Point2IsEqual(a1, b2)) {
            pt->X = (double)a1.X;
            pt->Y = (double)a1.Y;
            return true;
        }
        if (CG_Point2IsEqual(a2, b1) || CG_Point2IsEqual(a2, b2)) {
            pt->X = (double)a2.X;
            pt->Y = (double)a2.Y;
            return true;
        }
        return false;
    }

    int B = CG_Edge2Relation(b1, b2, a1, a2);
    if (B < 1) {
        return CG_Line2Intersect(a1, a2, b1, b2, pt);
    }

    return false;
}

#ifdef __cplusplus
}
#endif
#endif /* CG_TYPES_H__ */
