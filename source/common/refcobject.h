/*******************************************************************************
* Copyright Â© 2024-2025 Light Zhang <mapaware@hotmail.com>, MapAware, Inc.     *
* ALL RIGHTS RESERVED.                                                         *
*                                                                              *
* PERMISSION IS HEREBY GRANTED, FREE OF CHARGE, TO ANY PERSON OR ORGANIZATION  *
* OBTAINING A COPY OF THE SOFTWARE COVERED BY THIS LICENSE TO USE, REPRODUCE,  *
* DISPLAY, DISTRIBUTE, EXECUTE, AND TRANSMIT THE SOFTWARE, AND TO PREPARE      *
* DERIVATIVE WORKS OF THE SOFTWARE, AND TO PERMIT THIRD - PARTIES TO WHOM THE  *
* SOFTWARE IS FURNISHED TO DO SO, ALL SUBJECT TO THE FOLLOWING :               *
*                                                                              *
* THE COPYRIGHT NOTICES IN THE SOFTWARE AND THIS ENTIRE STATEMENT, INCLUDING   *
* THE ABOVE LICENSE GRANT, THIS RESTRICTION AND THE FOLLOWING DISCLAIMER, MUST *
* BE INCLUDED IN ALL COPIES OF THE SOFTWARE, IN WHOLE OR IN PART, AND ALL      *
* DERIVATIVE WORKS OF THE SOFTWARE, UNLESS SUCH COPIES OR DERIVATIVE WORKS ARE *
* SOLELY IN THE FORM OF MACHINE - EXECUTABLE OBJECT CODE GENERATED BY A SOURCE *
* LANGUAGE PROCESSOR.                                                          *
*                                                                              *
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR   *
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,     *
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON - INFRINGEMENT.IN NO EVENT   *
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE    *
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,  *
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER  *
* DEALINGS IN THE SOFTWARE.                                                    *
*******************************************************************************/
/*
** @file      refcobject.h
**  C reference count object api.
**
** @author    Liang Zhang <350137278@qq.com>
** @version   0.0.3
** @since     2020-12-09 21:12:10
** @date      2024-11-04 00:29:15
*/
#ifndef _REFC_OBJECT_H_
#define _REFC_OBJECT_H_

#if defined(__cplusplus)
extern "C"
{
#endif

#include "uatomic.h"
#include "thread_rwlock.h"

#define REFCOBJ_ALIGN_SIZE(sz)   ((((size_t)(sz) + sizeof(void*) - sizeof(char))/sizeof(void*)) * sizeof(void*))

#define REFCOBJ_CAST_OBJ(pv)  refc_object obj = (refc_object) pv; --obj


typedef struct
{
    void (*__final)(void *);
    ThreadRWLock_t __rwlock;
    uatomic_int  __refc;
    int type;
    void *addr[0];
} refc_object_t, *refc_object;


STATIC_INLINE void * refc_object_new (int type, size_t elemsz, void (*finalize)(void *))
{
    refc_object p = (refc_object) mem_alloc_zero(1, REFCOBJ_ALIGN_SIZE(sizeof(*p) + elemsz));
    p->__refc = 1;
    p->__final = finalize;
    p->type = type;
    RWLockInit(&p->__rwlock);
    return p->addr;
}


STATIC_INLINE void* refc_object_inc (void **ppv)
{
    refc_object p = (refc_object)(*ppv);
    if (p--) {
        if (uatomic_int_add(&p->__refc) > 0) {
            return (p->addr);
        }
    }
    return NULL;
}


STATIC_INLINE void refc_object_dec (void **ppv)
{
    refc_object p = (refc_object)(*ppv);
    if (p--) {
        if (uatomic_int_sub(&p->__refc) <= 0) {
            *ppv = NULL;
            p->__final(p->addr);
            RWLockUninit(&p->__rwlock);
            mem_free(p);
        }
    }
}


STATIC_INLINE int refc_object_type (void *pv)
{
    REFCOBJ_CAST_OBJ(pv);
    return obj->type;
}


/* lock for read only */
STATIC_INLINE int refc_object_lock_rd (void *pv, int istry)
{
    REFCOBJ_CAST_OBJ(pv);
    return RWLockAcquire(&obj->__rwlock, RWLOCK_STATE_READ, istry);
}


/* unlock for read only */
STATIC_INLINE int refc_object_unlock_rd (void *pv)
{
    REFCOBJ_CAST_OBJ(pv);
    return RWLockRelease(&obj->__rwlock, RWLOCK_STATE_READ);
}


/* lock for write and read */
STATIC_INLINE int refc_object_lock (void *pv, int istry)
{
    REFCOBJ_CAST_OBJ(pv);
    return RWLockAcquire(&obj->__rwlock, RWLOCK_STATE_WRITE, istry);
}


/* unlock for write and read */
STATIC_INLINE int refc_object_unlock (void *pv)
{
    REFCOBJ_CAST_OBJ(pv);
    return RWLockRelease(&obj->__rwlock, RWLOCK_STATE_WRITE);
}

#ifdef __cplusplus
}
#endif

#endif /* _REFC_OBJECT_H_ */
