/*******************************************************************************
* Copyright © 2024-2025 Light Zhang <mapaware@hotmail.com>, MapAware, Inc.     *
* ALL RIGHTS RESERVED.                                                         *
*                                                                              *
* PERMISSION IS HEREBY GRANTED, FREE OF CHARGE, TO ANY PERSON OR ORGANIZATION  *
* OBTAINING A COPY OF THE SOFTWARE COVERED BY THIS LICENSE TO USE, REPRODUCE,  *
* DISPLAY, DISTRIBUTE, EXECUTE, AND TRANSMIT THE SOFTWARE, AND TO PREPARE      *
* DERIVATIVE WORKS OF THE SOFTWARE, AND TO PERMIT THIRD - PARTIES TO WHOM THE  *
* SOFTWARE IS FURNISHED TO DO SO, ALL SUBJECT TO THE FOLLOWING :               *
*                                                                              *
* THE COPYRIGHT NOTICES IN THE SOFTWARE AND THIS ENTIRE STATEMENT, INCLUDING   *
* THE ABOVE LICENSE GRANT, THIS RESTRICTION AND THE FOLLOWING DISCLAIMER, MUST *
* BE INCLUDED IN ALL COPIES OF THE SOFTWARE, IN WHOLE OR IN PART, AND ALL      *
* DERIVATIVE WORKS OF THE SOFTWARE, UNLESS SUCH COPIES OR DERIVATIVE WORKS ARE *
* SOLELY IN THE FORM OF MACHINE - EXECUTABLE OBJECT CODE GENERATED BY A SOURCE *
* LANGUAGE PROCESSOR.                                                          *
*                                                                              *
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR   *
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,     *
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON - INFRINGEMENT.IN NO EVENT   *
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE    *
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,  *
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER  *
* DEALINGS IN THE SOFTWARE.                                                    *
*******************************************************************************/
/*
** @file      basetype.h
** @brief Base Definitions and Types, Bob Jenkins, Liang Zhang
**
** @author mapaware@hotmail.com
** @copyright © 2024-2030 mapaware.top All Rights Reserved.
** @version 0.0.33
**
** @since 2019-09-30 12:37:44
** @date      2024-12-18 17:15:16
**
** @note
*/
#ifndef BASETYPE_H_INCLUDED
#define BASETYPE_H_INCLUDED

#if defined(__cplusplus)
extern "C"
{
#endif

/**
 * __WINDOWS__ represents Windows Platform
 */
#if defined(_WIN32) || defined(__WINDOWS__)
  # ifndef WIN32_LEAN_AND_MEAN
    # define WIN32_LEAN_AND_MEAN
  # endif
  # ifndef __WINDOWS__
    # define __WINDOWS__
  # endif
#endif

#if defined(__WINDOWS__) && !defined(_WIN32_WCE) && !defined(__CYGWIN__)
  # if !(defined(_WINSOCKAPI_) || defined(_WINSOCK_H) || defined(__LWIP_OPT_H__) || defined(LWIP_HDR_OPT_H))
    /**
     *  The check above prevents the winsock2 inclusion if winsock.h already
     *    was included, since they can't co-exist without problems.
     */
    # include <WS2tcpip.h>
  # endif
#endif

/*
#undef _TIMESPEC_DEFINED
#include <sys/types.h>
*/

#if defined(__MINGW32__) || defined(__MINGW64__)
    # define __MINGW__   1
#endif

#if defined(__CYGWIN32__) || defined(__CYGWIN64__)
    # define __CYGWIN__   1
#endif

#if defined(__WINDOWS__)
	# undef __WIN64__	/* 64 bits */
	# undef __WIN32__	/* 32 bits */

    # ifdef _WIN64
        # define __WIN64__   1
    # else
        # define __WIN32__   1
    # endif

    # define stat64buf_t  struct __stat64
    # define lstat64      _stat64

    // 92 = '\\'
    # undef  PATH_SEPARATOR_CHAR
    # define PATH_SEPARATOR_CHAR       ((char) 92)

#elif defined(__CYGWIN__) || defined(__MINGW__)

    # undef  PATH_SEPARATOR_CHAR
    # define PATH_SEPARATOR_CHAR       ((char) 47)
#elif defined(__APPLE__)
    # include "TargetConditionals.h"

    # if TARGET_IPHONE_SIMULATOR
        // iOS Simulator
    # elif TARGET_OS_IPHONE
        // iOS device
    # elif TARGET_OS_MAC
        // Other kinds of Mac OS
    # else
    #   error "Unknown Apple platform"
    # endif

    // 47 = '/'
    # undef  PATH_SEPARATOR_CHAR
    # define PATH_SEPARATOR_CHAR       ((char) 47)
#elif defined(__linux__)

    # if _POSIX_C_SOURCE < 200809L
    #   undef _POSIX_C_SOURCE
    #   define _POSIX_C_SOURCE  200809L
    # endif

    # ifndef _LARGE_TIME_API
    #   define _LARGE_TIME_API
    #endif

    # include <sys/stat.h>

    # include <limits.h>
    # include <unistd.h>

    # define stat64buf_t  struct stat64

    // 47 = '/'
    # undef  PATH_SEPARATOR_CHAR
    # define PATH_SEPARATOR_CHAR       ((char) 47)
#elif defined(__unix__) // all unices not caught above
    // Unix

    # undef  PATH_SEPARATOR_CHAR
    # define PATH_SEPARATOR_CHAR       ((char) 47)
#elif defined(_POSIX_VERSION)
    // POSIX

    # undef  PATH_SEPARATOR_CHAR
    # define PATH_SEPARATOR_CHAR       ((char) 47)
#else
#   error "Unknown compiler"
#endif


#ifndef STDIO
    # include <stdio.h>
    # include <stdlib.h>
    # include <string.h>
    # include <assert.h>
    # include <stdarg.h>
    # include <malloc.h>

    # include <float.h>
    # include <limits.h>
    # include <stdint.h>

    # include <errno.h>
    # include <time.h>

    # define STDIO
#endif

#ifndef STDDEF
    # include <stddef.h>
    # include <ctype.h>
    # define STDDEF
#endif

#ifndef BCOPY
    # if defined(__WINDOWS__)
    #   define bcopy(s,d,n)    memcpy((void*)(d), (const void*)(s), (size_t)(n))
    # endif
    # define BCOPY
#endif

#ifndef BZERO
    # if defined(__WINDOWS__)
    #   define bzero(s,n)    memset((void*)(s), 0, (size_t)(n))
    # endif
    # define BZERO
#endif

#ifndef SNPRINTF
    # if defined(__WINDOWS__)
    #   define snprintf    _snprintf
    # endif
    # define SNPRINTF
#endif

#ifndef STRTOK
    # if defined(__WINDOWS__)
    #   define strtok_r    strtok_s
    # endif
    # define STRTOK
#endif


#ifndef NOWARNING_UNUSED
    # if defined(__GNUC__) || defined(__CYGWIN__)
        # define NOWARNING_UNUSED(x) __attribute__((unused)) x
    # else
        # define NOWARNING_UNUSED(x) x
    # endif
#endif

#ifndef STATIC_INLINE
    # if defined(_MSC_VER)
        # define STATIC_INLINE  NOWARNING_UNUSED(static) __forceinline
    # elif defined(__GNUC__) || defined(__CYGWIN__)
        # define STATIC_INLINE  NOWARNING_UNUSED(static) __attribute__((always_inline)) inline
    # else
        # define STATIC_INLINE  NOWARNING_UNUSED(static)
    # endif
#endif


#if defined(_MSC_VER)
    # define _TIMESPEC_DEFINED

    /* Type definitions for the basic sized types. */
    # include <basetsd.h>
    typedef SSIZE_T ssize_t;

    /* DEBUG_PRINT_ENABLED */
    # if !defined (NDEBUG) && defined (DEBUG_PRINT_ENABLED)
        # define DEBUG_PRINT_MSG(message, ...)  do { \
                time_t t; \
                struct tm *pt; \
                t = time(NULL); \
                pt = localtime(&t); \
                printf("(%04d-%02d-%02d %02d:%02d:%02d - %s:%d %s) - " \
                    message, \
                    pt->tm_year + 1900, pt->tm_mon + 1, pt->tm_mday, pt->tm_hour, pt->tm_min, pt->tm_sec, \
                    __FILE__, __LINE__, __FUNCTION__, \
                    __VA_ARGS__); \
                } while(0)
    # else
        # define DEBUG_PRINT_MSG(message, ...)
    # endif

#else /* non MSVC */
    # ifndef WINDOWS_CRTDBG_ON
    #   define WINDOWS_CRTDBG_ON
    # endif

    /* DEBUG_PRINT_ENABLED */
    # if !defined (NDEBUG) && defined (DEBUG_PRINT_ENABLED)
        # define DEBUG_PRINT_MSG(message, args...)  do { \
                    time_t t; \
                    struct tm *pt; \
                    t = time(NULL); \
                    pt = localtime(&t); \
                    printf("(%04d-%02d-%02d %02d:%02d:%02d - %s:%d %s) - " \
                        message, \
                        pt->tm_year + 1900, pt->tm_mon + 1, pt->tm_mday, pt->tm_hour, pt->tm_min, pt->tm_sec, \
                        __FILE__, __LINE__, __FUNCTION__, \
                        ##args); \
                    } while(0)
    # else
        # define DEBUG_PRINT_MSG(message, args...)
    # endif
#endif


/**
 * uniform int types
 */
#if defined (_SVR4) || defined (SVR4) || defined (__OpenBSD__) || \
    defined (_sgi) || defined (__sun) || defined (sun) || \
    defined (__digital__) || defined (__HP_cc)
    # include <inttypes.h>
#elif defined (_MSC_VER) && _MSC_VER < 1600
  # ifndef TYPEDEF_HAS_STDINT
  #   define TYPEDEF_HAS_STDINT
    /* VS 2010 (_MSC_VER 1600) has stdint.h */
    typedef __int8 int8_t;
    typedef unsigned __int8 uint8_t;
    typedef __int16 int16_t;
    typedef unsigned __int16 uint16_t;
    typedef __int32 int32_t;
    typedef unsigned __int32 uint32_t;
    typedef __int64 int64_t;
    typedef unsigned __int64 uint64_t;
  # endif
#elif defined (_AIX)
    # include <sys/inttypes.h>
#else
    # include <inttypes.h>
#endif

#ifndef HAS_BYTE_T_DEFINED
    typedef unsigned char byte_t;
    #define HAS_BYTE_T_DEFINED
#endif

typedef uint64_t ub8;
#define UB8MAXVAL 0xffffffffffffffffLL
#define UB8BITS 64

typedef int64_t sb8;
#define SB8MAXVAL 0x7fffffffffffffffLL

/* unsigned 4-byte quantities */
typedef uint32_t ub4;
#define UB4MAXVAL 0xffffffff

typedef int32_t sb4;
#define UB4BITS 32
#define SB4MAXVAL 0x7fffffff

typedef uint16_t ub2;
#define UB2MAXVAL 0xffff
#define UB2BITS 16

typedef int16_t sb2;
#define SB2MAXVAL 0x7fff

/* unsigned 1-byte quantities */
typedef unsigned char ub1;
#define UB1MAXVAL 0xff
#define UB1BITS 8

/* signed 1-byte quantities */
typedef signed char sb1;
#define SB1MAXVAL 0x7f


/**
 * check and config value for integer variable if var is:
 *   0  : set by default value (defval)
 *  -1  : set by maximum value (maxval)
 *  others: set not less than minval and not more than maxval
 */
#define CHKCONFIG_INT_VALUE(defval, minval, maxval, var) \
    ((var)==0?((var)=(defval)):((var)==-1?((var)=(maxval)):((var)<(minval)?((var)=(minval)):((var)>(maxval)?((var)=(maxval)):(var)))))


/**
* snprintf_chkd_V1()
*   A checked V1 version of snprintf() for both GCC and MSVC
*   No error.
* see:
*   <stdarg.h>
*   https://linux.die.net/man/3/snprintf
*
*   The functions snprintf() and vsnprintf() do not write more than size bytes
*    (including the terminating null byte ('\0')).
*   If the output was truncated due to this limit then the return value is the
*    number of characters (excluding the terminating null byte) which would have
*    been written to the final string if enough space had been available.
*   Thus, a return value of size or more means that the output was truncated.
*/
NOWARNING_UNUSED(static)
int snprintf_chkd_V1(char *outputbuf, size_t bufsize, const char *format, ...)
{
    int len;

    va_list args;
    va_start(args, format);
    len = vsnprintf(outputbuf, bufsize, format, args);
    va_end(args);

    if (len < 0 || len >= (int)bufsize) {
        /* output was truncated due to bufsize limit */
        len = (int) bufsize - 1;

        /* for MSVC */
        outputbuf[len] = '\0';
    }

    return len;
}


/**
* snprintf_chkd_V2()
*   A crashed on error version of snprintf.
*
*    If exitcode not given (= 0), same as snprintf_safe()
*/
NOWARNING_UNUSED(static)
int snprintf_chkd_V2(int exitcode, char *outputbuf, size_t bufsize, const char *format, ...)
{
    int len;

    va_list args;
    va_start(args, format);
    len = vsnprintf(outputbuf, bufsize, format, args);
    va_end(args);

    if (len < 0 || len >= (int)bufsize) {
        /* output was truncated due to bufsize limit */
        len = (int)bufsize - 1;

        /* for MSVC */
        outputbuf[len] = '\0';

        /* exit on error if exitcode given (not 0) */
        if (exitcode) {
            fprintf(stderr, "(%s:%d) fatal: output was truncated. (%s...)\n", __FILE__, __LINE__, outputbuf);
            exit(exitcode);
        }
    }

    return len;
}


/**
 * 新的程序应该使用: snprintf_safe
 */
NOWARNING_UNUSED(static)
int snprintf_safe(char *outputbuf, size_t bufsize, const char *format, ...)
{
    int len;

    va_list args;
    va_start(args, format);
    len = vsnprintf(outputbuf, bufsize, format, args);
    va_end(args);

    if (len < 0) {
        outputbuf[0] = '\0';
    } else {
        outputbuf[bufsize - 1] = '\0';
    }

    /**
     * if len >= bufsize, output was truncated due to bufsize limit;
     * if leb < 0, an error ocurred.
     */
    return len;
}


/**
 * 如果失败则中断运行. 初始化时使用这个函数减少代码检查
 */
NOWARNING_UNUSED(static)
int snprintf_chk_abort(char *outputbuf, size_t bufsize, const char *format, ...)
{
    int len;

    va_list args;
    va_start(args, format);
    len = vsnprintf(outputbuf, bufsize, format, args);
    va_end(args);

    if (len < 0 || len >= (int) bufsize) {
        outputbuf[0] = '\0';
        fprintf(stderr, "(%s:%d) fatal error when calling: vsnprintf.\n", __FILE__, __LINE__);
        abort();
        return -1;
    }

    outputbuf[bufsize - 1] = '\0';
    return len;
}


#define snprintf_V1    snprintf


/**
 * The compiler tries to warn you that you lose bits when casting from void *
 *   to int. It doesn't know that the void * is actually an int cast, so the
 *   lost bits are meaningless.
 *
 * A double cast would solve this (int)(uintptr_t)t->key. It first casts void *
 *   to uintptr_t (same size, no warning), then uintptr_t to int (number to
 *   number, no warning). Need to include <stdint.h> to have the uintptr_t type
 *   (an integral type with the same size as a pointer).
 */
#define ptr_cast_to_int(pv)      ((int) (uintptr_t) (void*) (pv))
#define int_cast_to_ptr(iv)      ((void*) (uintptr_t) (int) (iv))

#define ptr_cast_to_int64(pv)    ((int64_t) (uint64_t) (void*) (pv))
#define int64_cast_to_ptr(iv)    ((void*) (uint64_t) (int64_t) (iv))

#ifdef __cplusplus
}
#endif

#endif /* BASETYPE_H_INCLUDED */
